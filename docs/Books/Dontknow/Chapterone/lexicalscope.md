# 词法阶段

```
大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。词法作用域就是定义在词法阶段的作用域，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。部分情况存在欺骗词法作用域。
```
```
下面代码包含三个词法作用域
全局作用域{
	fn函数作用域{
		a
		b
		fn1函数作用域{
			c
		}
	}
}
我们来分析console.log(a,b,c);
先来找a，从fn1开始进行RHS查找，没有找到，根据作用域嵌套去查找fn函数作用域，查找到fn函数的参数a，之前说过，函数的参数变量处于函数作用域中，参数a的值为fn(2);传入得知为2。
再来找b，进行RHS查找，fn1作用域未找到，在fn作用域中找到了。值为4
再来找c，进行RHS查找，fn1作用域中找到了，值为fn1(b*2)决定为8
再来分析console.log(c)；进行RHS查找，在fn作用域中未找到，再去全局作用域中也没有找到。因此报错c is not defined
```
```js
function fn(a) {
    var b = a * 2;
    function fn1(c){
        console.log(a,b,c); //2,4,8
    }
    fn1(b*2);
    console.log(c);//c is not defined
}

fn(2);
```
```
函数的参数属于该函数的作用域，而不属于该函数所在的作用域
```

## 查找

```
作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。
```

```
全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。通过这种技术可以访问那些被同名变量所遮蔽的全局变量。
```

```js
var a = 1;
function fn(){
  var a = 2;
  console.log(window.a);
}
fn();//1
```

但非全局的变量如果被遮蔽了，无论如何都无法被访问到。一个解决办法手动将值赋值给全局变量

```js
function foo(a) {
  obj.a = a;
}

let obj = {}

foo(2);

console.log(obj.a);//2
```

```
无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。
```

```
词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，“对象属性访问规则”会分别接管对 bar 和 baz 属性的访问。
```

## 欺骗词法

（词法作用域完全由写代码期间函数所声明的位置来定义）但是JavaScript有两种机制可以欺骗词法作用域。欺骗词法作用域也就是在运行时改变词法作用域，但是要注意的是欺骗词法作用域会导致性能下降。

### eval
```
JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。
```

```js
var b = 2;
function fn(str,a) {
  eval(str);
  console.log(a,b);
}
fn('var b = 3',1);//1,3
```

```
当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1,2”。在这个例子中，为了展示的方便和简洁，我们传递进去的“代码”字符串是固定不变的。而在实际情况中，可以非常容易地根据程序逻辑动态地将字符拼接在一起之后再传递进去。eval(..) 通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。 
```

```
如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改
在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。
在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。 
```

```js
var b = 2;
function fn(str,a) {
  "use strict";
  // 严格模式下eval()不会影响其声明的词法作用域，它有自己的词法作用域，因此在函数词法作用域中不会遮盖全局作用域的b = 2
  eval(str);
  console.log(a,b);
}
fn('var b = 3',1);//1,2
```

### 书中提到的与eval()相似的功能

1. setTimeout（）与setInterval（）第一个参数可以是字符串，这个字符串可以被解释为一段动态生成的函数代码，**注意书中的内容已经废除了**

```js
// setTimeout("console.log('哈哈哈')", 1000);//Callback must be a function. Received "console.log('哈哈哈')"

setInterval("console.log('哈哈哈')",1000);// Callback must be a function. Received "console.log('哈哈哈')"
```

2. new Function（）最后一个参数可以接受代码字符串，并将其转换为动态生成的函数

```
1, Function中的参数全部是字符串。

2, 构造函数的作用是将参数连接起来构成函数。

       * 如果参数只有一个即是表示函数体。

       * 如果参数多个，最后一个为函数体，前面的全是表示函数参数。

       * 如果没有参数，即创建空函数。
```
```js
function fn() {
    (new Function("a = 3"))();
}
fn();
console.log(a); // 动态为全局添加一个变量a值为3
```
### with

```
JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with 关键字
with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身 
```

```js
var obj = {
  a: 1,
  b: 2,
  c: 3
};
// 单调乏味的重复 "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式,访问修改对象的属性值
with(obj) {
  a = 3;
  b = 4;
  c = 5;
}
console.log(obj); //{a: 3, b: 4, c: 5}
```

```
with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。
```

```js
function fn1() {
   function foo(obj) {
     with(obj) {
       a = 2;
       c = 1;          }
   }
   var o1 = {
     a: 3
   };
   var o2 = {
     b: 3
   };
   foo(o1);
   console.log(o1.a); // 2
   foo(o2);
   console.log(o2.a); // undefined
 }
 fn1();
 console.log(a); // 2——不好，a 被泄漏到全局作用域上了！
 console.log(c);//1
```

```
可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符，
因此进行了正常的 LHS 标识符查找（查看第 1 章）。进行LHS查找时，没有查找到，会在全局作用域中创建这个变量
o2 的作用域、foo(..) 的作用域、fn1(...)的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行时，自动创建了一个全局变量（因为是非严格模式）
```

```
尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。
```

```js
function foo(obj) {
  with(obj) {
    var d = 4;
  }
  console.log(d); // 4
}
var o1 = {
  a: 3
};
var o2 = {
  b: 3
};
foo(o1);//4
console.log(o1.a); // 3
foo(o2);//4
console.log(o2.a); // undefined
console.log(d); //d is not defined
```

```
总结：不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..) 也被禁止了。
```

# 性能

```
eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。这是它们两的优点，但是它们两的优点带来的收益小于它们两对性能的影响，所以不推荐使用
```

```
它们两是怎样影响性能的呢？
JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。
一句话概括：就是因为它们两的存在，增加了不确定性，引擎无法按照静态的那种方式预测和进行有效的规划优化，甚至不优化，影响运行速度 
```